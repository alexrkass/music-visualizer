// Generated by CoffeeScript 1.9.3
(function() {
  window.LoopVisualizer = (function() {
    var INIT_RADIUS, RINGCOUNT, SEGMENTS, colors, init, levels, loopGeom, loopShape, rings, update;
    console.log("Visualizer being defined");
    levels = [];
    colors = [];
    rings = [];
    INIT_RADIUS = 50;
    SEGMENTS = 512;
    loopShape = new THREE.Shape();
    loopShape.absarc(0, 0, INIT_RADIUS, 0, Math.PI * 2, false);
    loopGeom = loopShape.createPointsGeometry(SEGMENTS / 2);
    loopGeom.dynamic = true;
    RINGCOUNT = 160;
    init = function() {
      var container, freqByteData, k, len, line, loopHolder, m, ref, ring, scale, timeByteData;
      console.log("Visualizer initialize started");
      container = document.createElement('div');
      document.body.appendChild(container);
      window.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000000);
      camera.position.z = 2000;
      window.scene = new THREE.Scene();
      scene.add(camera);
      window.renderer = new THREE.WebGLRenderer({
        antialias: false,
        sortObjects: false
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
      freqByteData = new Uint8Array(analyser.frequencyBinCount);
      timeByteData = new Uint8Array(analyser.frequencyBinCount);
      loopHolder = new THREE.Object3D();
      scene.add(loopHolder);
      scale = 1;
      ref = [1, RINGCOUNT];
      for (k = 0, len = ref.length; k < len; k++) {
        ring = ref[k];
        m = new THREE.LineBasicMaterial({
          color: 0xffffff,
          linewidth: 1,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true
        });
        line = new THREE.Line(loopGeom, m);
        rings.push(line);
        scale *= 1.05;
        line.scale.x = scale;
        line.scale.y = scale;
        loopHolder.add(line);
        levels.push(0);
        colors.push(0);
        return;
      }
    };
    console.log("here");
    update = function(noisePos) {
      var BIN_COUNT, aveLevel, freqByteData, hue, i, j, k, l, len, len1, len2, n, normLevel, o, ref, ref1, ref2, ringId, scaled_average, sum, timeByteData;
      freqByteData = new Uint8Array(analyser.frequencyBinCount);
      timeByteData = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(freqByteData);
      analyser.getByteTimeDomainData(timeByteData);
      sum = 0;
      BIN_COUNT = 512;
      ref = [1, BIN_COUNT];
      for (k = 0, len = ref.length; k < len; k++) {
        i = ref[k];
        sum += freqByteData[i];
      }
      aveLevel = sum / BIN_COUNT;
      scaled_average = aveLevel / 256;
      levels.push(scaled_average);
      levels.shift(1);
      n = Math.abs(perlin.noise(noisePos, 0, 0));
      colors.push(n);
      colors.shift(1);
      ref1 = [1, SEGMENTS];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        j = ref1[l];
        loopGeom.vertices[j].z = timeByteData[j] * 2;
        loopGeom.vertices[SEGMENTS].z = loopGeom.vertices[0].z;
      }
      loopGeom.verticesNeedUpdate = true;
      ref2 = [1, RINGCOUNT];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        i = ref2[o];
        ringId = RINGCOUNT - i - 1;
        normLevel = levels[ringId] + 0.01;
        hue = colors[i];
        // rings[i].material.color.setHSL(hue, 1, normLevel * .8);
        // rings[i].material.linewidth = normLevel * 3;
        // rings[i].material.opacity = normLevel;
        return;
      }
    };
    return {
      init: init,
      update: update
    };
  }());

  LoopVisualizer.init();

}).call(this);
