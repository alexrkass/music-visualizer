// Generated by CoffeeScript 1.9.3
(function() {
  var LoopViz;

  LoopViz = (function(context, elem) {
    var analyser, camera, container, init, renderer, scene, update;
    analyser = context.createAnalyser();
    elem = document.getElementbyId(elem);
    container = document.createElement('div');
    document.body.appendChild(container);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000000);
    camera.position.z = 2000;
    scene = new THREE.Scene();
    scene.add(camera);
    renderer = new THREE.WebGLRenderer({
      antialias: false,
      sortObjects: false
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    init = function() {
      var INIT_RADIUS, SEGMENTS, freqByteData, k, len, line, loopGeom, loopHolder, loopShape, m, ref, results, ring, rings, scale, timeByteData;
      freqByteData = new Uint8Array(analyser.frequencyBinCount);
      timeByteData = new Uint8Array(analyser.frequencyBinCount);
      loopShape = new THREE.Shape();
      INIT_RADIUS = 50;
      SEGMENTS = 512;
      loopShape.absarc(0, 0, INIT_RADIUS, 0, Math.PI * 2, false);
      loopGeom = loopShape.createPointsGeometry(SEGMENTS / 2);
      loopGeom.dynamic = true;
      loopHolder = new THREE.Object3D();
      scene.add(loopHolder);
      scale = 1;
      rings = [];
      ref = [1, RINGCOUNT];
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        ring = ref[k];
        m = new THREE.LineBasicMaterial({
          color: 0xffffff,
          linewidth: 1,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true
        });
        line = new THREE.Line(loopGeom, m);
        rings.push(line);
        scale *= 1.05;
        line.scale.x = scale;
        line.scale.y = scale;
        loopHolder.add(line);
        levels.push(0);
        results.push(colors.push(0));
      }
      return results;
    };
    timeByteData;
    update = function() {
      var BIN_COUNT, aveLevel, hue, i, j, k, l, len, len1, len2, n, normLevel, o, ref, ref1, ref2, results, ringId, sum;
      analyser.getByteFrequencyData(freqByteData);
      analyser.getByteTimeDomainData(timeByteData);
      sum = 0;
      BIN_COUNT = 512;
      ref = [1, BIN_COUNT];
      for (k = 0, len = ref.length; k < len; k++) {
        i = ref[k];
        sum += freqByteData[i];
      }
      aveLevel = sum / BIN_COUNT;
      levels.push(scaled_average);
      levels.shift(1);
      n = Math.abs(perlin.noise(noisePos, 0, 0));
      colors.push(n);
      colors.shift(1);
      ref1 = [1, SEGMENTS];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        j = ref1[l];
        loopGeom.vertices[j].z = timeByteData[j] * 2;
        loopGeom.vertices[SEGMENTS].z = loopGeom.vertices[0].z;
      }
      loopGeom.verticesNeedUpdate = true;
      ref2 = [1, RINGCOUNT];
      results = [];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        i = ref2[o];
        ringId = RINGCOUNT - i - 1;
        normLevel = levels[ringId] + 0.01;
        hue = colors[i];
        rings[i].material.color.setHSL(hue, 1, normLevel * .8);
        rings[i].material.linewidth = normLevel * 3;
        results.push(rings[i].material.opacity = normLevel);
      }
      return results;
    };
    return {
      init: init,
      update: update,
      loopHolder: loopHolder,
      vizParams: vizParams
    };
  });

}).call(this);
